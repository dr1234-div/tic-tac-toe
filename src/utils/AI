// chessPlace:已经落子的集合
// chessWidth：棋盘的宽高，默认15
// goalX：最佳位置的横坐标

function computerDown() {
        // 初始化score评分组
        for (var i = 0; i < chessWidth; i++) {
            for (var j = 0; j < chessWidth; j++) {
                score[i][j] = 0;
            }
        }
        // 五元组中黑棋(玩家)数量（默认玩家先行）
        var playerNum = 0;
        // 五元组中白棋(电脑)数量
        var computerNum = 0;
        // 五元组临时得分
        var tempScore = 0;
        // 最大得分
        var maxScore = -1;

        // 横向寻找
        for (var i = 0; i < chessWidth; i++) {
            for (var j = 0; j < chessWidth - 4; j++) {
                for (var k = j; k < j + 5; k++) {
                    // 如果是玩家落得子
                    if (chessPlace[k][i] == 1) {
                        // 记录玩家落子数量
                        playerNum++;
                    } else if (chessPlace[k][i] == 2) { //如果是电脑落子
                    // 记录电脑落子数量
                        computerNum++;
                    }
                }
                // 将每一个五元组中的黑棋和白棋个数传入评分表中，得到对应的分数
                tempScore = chessScore(playerNum, computerNum);
                // 为该五元组的每个位置添加分数------------------------------------------
                for (var k = j; k < j + 5; k++) {
                    score[k][i] += tempScore;
                }
                // 清空五元组中棋子数量和五元组临时得分（为什么要清空零食得分，是因为后面的遍历也需要使用这些临时变量）
                playerNum = 0;
                computerNum = 0;
                tempScore = 0;
            }
        }

        // 纵向寻找
        for (var i = 0; i < chessWidth; i++) {
            for (var j = 0; j < chessWidth - 4; j++) {
                for (var k = 0; k < j + 5; k++) {
                    if (chessPlace[i][k] == 1) {
                        playerNum++;
                    } else if (chessPlace[i][k] == 2) { 
                        computerNum++;
                    }
                }
                tempScore = chessScore(playerNum, computerNum);
                for (var k = j; k < j + 5; k++) {
                    score[i][k] += tempScore;
                }
                playerNum = 0;
                computerNum = 0;
                tempScore = 0;
            }
        }


        // 反斜线寻找

        // 反斜线上侧部分
        for (var i = chessWidth - 1; i >= 4; i--) {
            for (var k = i, j = 0; j < chessWidth && k >= 0; j++, k--) {
                var m = k; //x 14 13
                var n = j; //y 0  1
                for (; m > k - 5 && k - 5 >= -1; m--, n++) {
                    if (chessPlace[m][n] == 1) {
                        playerNum++;
                    } else if (chessPlace[m][n] == 2) { 
                        computerNum++;
                    }
                }
                // 注意在斜向判断时，可能出现构不成五元组（靠近棋盘的四个顶角）的情况，所以要忽略这种情况
                if (m == k - 5) {
                    tempScore = chessScore(playerNum, computerNum);
                    for (m = k, n = j; m > k - 5; m--, n++) {
                        score[m][n] += tempScore;
                    }
                }
                playerNum = 0;
                computerNum = 0;
                tempScore = 0;
            }
        }
        // 反斜线下侧部分
        for (var i = 1; i < 15; i++) {
            for (var k = i, j = chessWidth - 1; j >= 0 && k < 15; j--, k++) {
                var m = k; //y 1 
                var n = j; //x 14
                for (; m < k + 5 && k + 5 <= 15; m++, n--) {
                    if (chessPlace[n][m] == 1) {
                        playerNum++;
                    } else if (chessPlace[n][m] == 2) {
                        computerNum++;
                    }
                }
                // 注意在斜向判断时，可能出现构不成五元组（靠近棋盘的四个顶角）的情况，所以要忽略这种情况
                if (m == k + 5) {
                    tempScore = chessScore(playerNum, computerNum);
                    for (m = k, n = j; m < k + 5; m++, n--) {
                        score[n][m] += tempScore;
                    }
                }
                playerNum = 0;
                computerNum = 0;
                tempScore = 0;
            }
        }

        // 正斜线寻找

        // 正斜线上侧部分
        for (var i = 0; i < chessWidth - 1; i++) {
            for (var k = i, j = 0; j < chessWidth && k < chessWidth; j++, k++) {
                var m = k;
                var n = j;
                for (; m < k + 5 && k + 5 <= chessWidth; m++, n++) {
                    if (chessPlace[m][n] == 1) {
                        playerNum++;
                    } else if (chessPlace[m][n] == 2) { 
                        computerNum++;
                    }
                }
                // 注意在斜向判断时，可能出现构不成五元组（靠近棋盘的四个顶角）的情况，所以要忽略这种情况
                if (m == k + 5) {
                    tempScore = chessScore(playerNum, computerNum);
                    for (m = k, n = j; m < k + 5; m++, n++) {
                        score[m][n] += tempScore;
                    }
                }
                playerNum = 0;
                computerNum = 0;
                tempScore = 0;
            }
        }

        // 正斜线下侧部分
        for (var i = 1; i < chessWidth - 4; i++) {
            for (var k = i, j = 0; j < chessWidth && k < chessWidth; j++, k++) {
                var m = k;
                var n = j;
                for (; m < k + 5 && k + 5 <= chessWidth; m++, n++) {
                    if (chessPlace[n][m] == 1) {
                        playerNum++;
                    } else if (chessPlace[n][m] == 2) { 
                        computerNum++;
                    }
                }
                // 注意在斜向判断时，可能出现构不成五元组（靠近棋盘的四个顶角）的情况，所以要忽略这种情况
                if (m == k + 5) {
                    tempScore = chessScore(playerNum, computerNum);
                    for (m = k, n = j; m < k + 5; m++, n++) {
                        score[n][m] += tempScore;
                    }
                }
                playerNum = 0;
                computerNum = 0;
                tempScore = 0;
            }
        }

        // 从空位置中找到得分最大的位置-----------------------------------------------------------------
        for (var i = 0; i < chessWidth; i++) {
            for (var j = 0; j < chessWidth; j++) {
                if (chessPlace[i][j] == 0 && score[i][j] > maxScore) {
                    goalX = i;
                    goalY = j;
                    maxScore = score[i][j];
                }
            }
        }
        if (goalX != -1 && goalY != -1 && chessPlace[goalX][goalY] == 0) {
            // 落子
            drawChess(goalX, goalY, false);
            // 保存游戏数据
            computerData();
            // 保存该位置的落子
            chessPlace[goalX][goalY] = 2;
            // 判断输赢
            if (win(goalX, goalY, num = 2)) {
                gameOver = true;
                computerData(true);
                isMan = true;
                var choice = confirm("你输了，再来一局？");
                failMp3.play();
                if (choice) {
                    clear();
                    playerData("", "clearPath");
                    computerData("", "clearPath");
                    gameOver = false;
                }
            } else if (tie()) {
                gameOver = true;
                isMan = true;
                var choice = confirm("占成平局，再来一局？");
                if (choice) {
                    clear();
                    playerData("", "clearPath");
                    computerData("", "clearPath");
                    gameOver = false;
                }
            } else {
                isMan = true;
            }
        }

    }
